#' Creates a character vector of p-value stars
#' @param .p_value Numeric vector of p-values
#' @return Character vector of stars
#' @keywords internal
create_stars <- function(.p_value) {
  stars <- dplyr::case_when(
    .p_value < 0.010 ~ "***",
    .p_value < 0.050 ~ "**",
    .p_value < 0.100 ~ "*",
    TRUE             ~ " " # Returning a space is easier for excel manipulation
  )
  return(stars)
  # "\u2020" - Unicode symbol for DAGGER: â€ 
  # Saving for eventual need in subgroup differences
}

#' Standard function for repairing and creating file path for excel
#' @param .output_file Name of exported file; defaults to "extract.xlsx"
#' @param .output_path Directory to save Excel; defaults to working directory
#' @param .x If object passed, will attempt
#' @return String specifying target file location
#' @keywords internal
create_excel <- function(.output_file = "extract.xlsx",
                         .output_path = NA_character_,
                         .x){

  # Extracting from path from name if unprovided, returns "." if not specified
  # if (is.null(.output_path)) {
  #   .output_path <- dirname(.output_file)
  # }
  .output_path <- normalizePath(.output_path)
  # Checking that the path specified exists
  if (!dir.exists(.output_path)) {
    stop(.output_path, " doesn't exist")
  }

  # Ensuring that file name is just the file name
  .output_file <- basename(.output_file)
  # Appending .xlsx to .output_file if doesn't already exist
  .output_file <- dplyr::if_else(stringr::str_detect(.output_file, "\\.xlsx$"),
                               .output_file,
                               paste0(.output_file, ".xlsx"))
  final_path <- file.path(.output_path, .output_file)
  # If .x is specified, write to the specified file path
  if (!missing(.x)) {
    # Handling the passing of workbook objects
    if (inherits(.x, "Workbook")) {
      openxlsx::saveWorkbook(.x, final_path, overwrite = TRUE)
    } else {
      writexl::write_xlsx(.x, final_path)
    }
  }
  # Returning repaired file name
  return(final_path)
}

#' Argument matching with defaults
#'
#' This is a version of \code{\link{match.call}} which also includes default arguments.
#'
#' @param definition a function, by default the function from which match.call is called. See details.
#' @param call an unevaluated call to the function specified by definition, as generated by call.
#' @param expand.dots logical. Should arguments matching \code{...} in the call be included or left as a \code{...} argument?
#' @param envir an environment, from which the \code{...} in call are retrieved, if any.
#'
#' @return An object of class call.
#'
#' @author Neal Fultz (From Stackoverflow)
#' @references \url{http://stackoverflow.com/questions/14397364/match-call-with-default-arguments/}
#'
#' @examples
#'
#' foo <- function(x=NULL,y=NULL,z=4, dots=TRUE, ...) {
#'   mdrcAnalysis:::match.call.defaults(expand.dots=dots)
#' }
#'
#' foo(4,nugan='hand')
#' foo(dots=FALSE,who='ami')
#'
match.call.defaults <- function(definition = sys.function(sys.parent()),
                                call = sys.call(sys.parent()),
                                expand.dots = TRUE,
                                envir = parent.frame(2L)) {
  call <- match.call(definition, call, expand.dots, envir)
  # Preventing lazy evaluation environment scoping issues
  for (i in seq_along(call)) {
    if (names(call)[i] != "" & names(call)[i] != ".dataset") call[[i]] <- eval(call[[i]], envir)
  }

  formals <- formals(definition)

  if (expand.dots && '...' %in% names(formals))
    formals[['...']] <- NULL

  for (i in setdiff(names(formals), names(call)))
    call[i] <- list(formals[[i]])

  match.call(definition, call, TRUE, envir)
}

#' Creating latex safe text
#' @param .x Character vector to coerce
#' @returns Character vector with special characters formatted to be LaTeX safe
str_repair_latex <- function(.x){
  .x_repaired <- stringr::str_replace_all(.x, "_", " ") %>%
    stringr::str_replace_all("\\n", " ") %>%
    stringr::str_replace_all("\\\\", "") %>%
    stringr::str_replace_all("%", "$\\\\%$") %>%
    stringr::str_replace_all("&","\\\\&") %>%
    stringr::str_replace_all("\\$","\\\\$") %>%
    stringr::str_replace_all("#","\\\\#") %>%
    stringr::str_replace_all("_","\\\\_")
  return(.x_repaired)
}

#' Paste with NA suppression
#' @param ... One or more objects that can be converted to character vectors.
#' @param sep Character string to separate terms
#' @param collapse Optional string to separate terms
#' @returns Result of base::paste call ignoring all NULL, NA, or 0-length args
#' If all arguments of ... are excluded, then return NA_character_
paste_na <- function(..., sep = " ", collapse = NULL) {
  # Removing all NA arguments
  x <- list(...) %>%
    # Removing any 0 length elements
    purrr::compact() %>%
    # Nested discard because arg components can be vectors to trim
    purrr::modify(~purrr::discard(., ~is.na(.))) %>%
    purrr::compact() %>%
    purrr::discard(~all(is.na(.)))
  if (length(x) == 0) {
    x <- NA_character_
  } else {
    x <- do.call("paste",args = c(x,"sep" = sep,"collapse" = collapse))
  }
  return(x)
}

#' Call Trail
#'
#' Generate dataframe of session information
#' This information can be joined to extracts for documentation purposes
#' @param call parameter to provide results of \link[mdrcAnalysis]{match.call.defaults}
#' @returns Tibble containing:
#'  filepath (if script run in RStudio)
#'  username
#'  datetime with timezone
#'  (Note: timezone will be EST because that's where MDRC Servers Run)
#'  R Version
#'  packages and version numbers
#'  @keywords internal


trail <- function(call = NA_character_) {

  # Create named vector with each package and version
  pkg_vrs1 <- sapply(sessionInfo()[[9]], function(.x) .x$Version)

  # Flatten vector to single string with package names and versions
  pkg_vrs2 <- paste(names(pkg_vrs1), pkg_vrs1, sep = " ", collapse = ", ")

  # Get file path
  ## Only works in RStudio, otherwise returns blank
  t <- try(rstudioapi::getActiveDocumentContext()$path)

  # Get the arguments from the parent function
  arg_names <- names(call)[-1]

  arg_values <- as.list(call)[-1]

  arg_string <- paste(arg_names, arg_values, sep = "=", collapse = ", ")


  # Create data frame of trail information
  df <- tibble::tibble(filepath = t[[1]],
                       user     = Sys.info()[[7]],
                       datetime = format(Sys.time(), format = "%F %R %Z"),
                       RVersion = sessionInfo()[[1]]$version.string,
                       Packages = pkg_vrs2,
                       FunctionParams = arg_string)

  return(df)
}

#' Match an argument to a character vector with an option for NULL return
#'
#' This is equivalent to \link[base:match.arg]{base::match.arg} with a few key
#' differences:
#' \itemize{
#'   \item Explicitly passing \code{NULL} will return NULL instead of the first match
#'   \item If \code{.several_ok} is TRUE, then ALL elements of \code{.arg} must have
#'   a partial match
#'   \item If \code{.several_ok} is TRUE, then matched elements can only be used once.
#' }
#' This is done to facilitate easy argument verification while still allowing for an
#' intuitive way specify that none of the options should be taken
#'
#' @param .arg A character vector (of length one unless \code{.several_ok} is TRUE) or
#' NULL which will return NULL
#' @param .choices A character vector of candidate values, often missing. See
#' \link[base:match.arg]{base::match.arg} for details.
#' @param .several_ok logical specifying if \code{.arg} should be allowed to have more
#' than one element.
#' @returns The unabbreviated version of the exact or unique partial match if exists;
#' otherwise an error is signalled if \code{.several_ok} is \code{FALSE} as per default.
#' When \code{.several_ok} is \code{TRUE}, then all elements of \code{.arg} must match
#' and these are returned. If \code{NULL} is passed, then \code{NULL} is returned
match_arg_null <- function(.arg, .choices, .several_ok = FALSE) {
  # Checking if NULL passed
  if (is.null(.arg)) {
    return(NULL)
  } else if(!is.character(.arg)) {
    stop("'.arg' must be NULL or a character vector")
  }
  if (missing(.choices)) {
    formal.args <- formals(sys.function(sysP <- sys.parent()))
    .choices <- eval(formal.args[[as.character(substitute(.arg))]],
                    envir = sys.frame(sysP))
  }
  # If only 1 match allowed
  if (!.several_ok) {
    # Checking if identical to default
    if (identical(.arg, .choices)) {
      return(.choices[1])
    }
    # Checking is more than 1 .arg passed
    if (!is_string(.arg)) {
      stop("'.arg' must be of length 1")
    }
  }

  # Perform partial matching
  i <- pmatch(.arg, .choices, nomatch = 0L, duplicates.ok = FALSE)

  # If any fail, then provide error
  if (any(is.na(i))) {
    stop("match not found for ",
         paste(.arg[which(is.na(i))], sep = ", "),
         " in '.arg'" )
  }

  return(.choices[i])
}

#' Sample Size Function
#'
#' Returns the sample size of the entire data set and by treatment group variables
#'
#' @param .dataset entire data set
#' @param .treatment specify treatment group
#'
#' @return tibble with row of sample size data
#'
#' @examples
#'
#' mdrcAnalysis:::sample_size(
#'            .dataset = sim_data_robust_reg,
#'            .treatment = "treatment"
#'             )
#'
sample_size <- function (.dataset
                        ,.treatment = NA_character_){

  #####################################
  # sample size of the entire data set
  #####################################

  N <- data.frame(n_total = nrow(.dataset))

  #####################################
  # sample size title
  #####################################

  sampleSizeTitle <- data.frame(sample_size = "sample_size")

  #####################################
  # sample sizes of groups
  #####################################
  if (!is.na(.treatment)) {
    byGroupN <-
      .dataset %>%
      dplyr::group_by(!!sym(.treatment)) %>%
      dplyr::summarise(N = dplyr::n()) %>%
      tidyr::pivot_wider(names_from = !!sym(.treatment),
                         names_glue = paste0("n_", "{", .treatment, "}"),
                         values_from = N)
  } # end if .treatment provided

  # combined all the data frames together here
  if (!is.na(.treatment)) {
    allNs <- dplyr::bind_cols(sampleSizeTitle, N, byGroupN)
  } else {
    allNs <- dplyr::bind_cols(sampleSizeTitle, N)
  }

  return(allNs)

}



#' Function for creating formulas
#'
#' Returns a formula object from provided variables
#'
#' Generally used within an inner function which calls only one model at a time.
#'
#' @param .TmntVar character string with name of desired treatment variable
#' @param .CoVars  character string with names of desired covariates
#' @param .DepVar  character string with name of dependent variable.
#'
#' @return tibble with row of sample size data
#'
#' @examples
#' \dontrun{
#' formula <-
#' create_formula(.TmntVar = .TmntVar,
#'                .CoVars  = .Covars,
#'                .DepVar  = .DepVar)}
#'

create_formula <- function(
    .TmntVar = NA_character_,
    .CoVars = NA_character_,
    .DepVar = NA_character_
){

  # Creating Formula for linear model
  ## String of covariates
  CV <- paste_na(.CoVars, collapse = " + ")

  ## RHS of base formula
  X <- paste_na(.TmntVar, CV, sep = " + ")

  ## Full Formula as string
  modFormulaString <- paste_na(.DepVar, X, sep = " ~ ")

  ## string to formula
  modFormula <- stats::as.formula(modFormulaString)

  return(list(modFormula = modFormula,
              modFormulaString = modFormulaString))

}

