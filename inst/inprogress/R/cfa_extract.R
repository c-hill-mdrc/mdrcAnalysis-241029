#' Confirmatory Factor Analysis Extract
#'
#' Generates and extracts loadings and fit from \link[lavaan:cfa]{lavaan::cfa}
#'
#' @details
#' # Specifying Model
#'
#' `.latent_indicators` support 3 types of input:
#' * The string to direclty use as a model for \link[lavaan:cfa]{lavaan::cfa}
#' * Character vector of lavaan style "formulas" as seen in
#'   \link[lavaan:model.syntax]{lavaan::model.syntax}
#' * Character vector of latent variables
#'
#' Either of the first two options are required if any other operator besides "=~" is desired.
#'
#' In the case of the third option, the lavaan formulas are generated by pairing the latent
#' variables with `.latent_indicators`. `.latent_indicators` can be specified in two ways:
#' * Character vector of the right hand side corresponding to the indicators,
#'   e.g. `c("x1 + x2", "x3 + x4")`
#' * List of character vectors containing each latent indicators,
#'   e.g `list(c("x1", "x2"), c("x3", "x4"))`
#'
#' # Loading Parameters
#'
#' `.loading_parameters` determines which parameters to extract and display. selection can be
#' achieved with either the natural language prompts listed here or  by using the actual names
#' available in the results of lavaan::parameterestiamtes(standadized = TRUE). Note that lhs and rhs
#' are always included and renamed.
#' * Operator ~ `op`
#' * Estimate ~ `est`
#' * Standard Error ~ `se`,
#' * Z Score ~ `z`
#' * P Value ~ `pvalue`
#' * Confidence Interval Lower ~ `ci.lower`
#' * Confidence Interval Upper ~ `ci.upper`
#' * Standardized Estimate on Latent ~ `std.lv`
#' * Standardized Estimates on All ~ `std.all`
#' * Standardized Estimates on All Excluding Exogenous ~ `std.nox`
#' By default, only "Standardized Esatimates on All" is selected
#'
#' @param .dataset Source dataframe. If column specified as an arderd factor, lavaan will interpret as
#' an ordinal categorical variable
#' @param .latent_variables Latent variable specifications. See Details for possible input options
#' @param .latent_indicators Vector of indicator components to pair with \code{.latent_variables} or list
#' of indicator vectors
#' @param .latent_labels Labels associated with .latent_variables. Named character vectors or a label
#' dataframe alloww for more robust matching
#' @param .fit_measures Fit measures to calculate and display from \link[lavaan:fitMeasures]{lavaan::fitMeasures}
#' @param .loading_parameters Loading parameters to display from
#' \link[lavaan:parameterEstimates]{lavaan::parameterEstiamtes}
#' @param .output_path Path to output excel file
#' @param .output_file Name of output excel file
#' @returns list of 2 elements.
#' First element is a tibble containing fit measures.
#' Second element is a tibble containing loadings
#' @examples
#' cfa_extract(
#'   lavaan::HolzingerSwineford1939,
#'   c("visual", "textual", "speed"),
#'   c("x1 + x2 + x3", "x4 + x5 + x6", "x7 + x8 + x9"),
#'   .output_path = "/path/to/project/directory",
#'   .output_file = "cfa_file_name.xlsx")
#' @export
cfa_extract <- function(.dataset,
                        .latent_variables,
                        .latent_indicators,
                        .latent_labels,
                        .fit_measures = c("cfi", "rmsea"),
                        .loading_parameters = c("Standardized Estimates on All"),
                        .output_path,
                        .output_file) {
  # Generating Model based on input specification

  # Check if .latent_variables is ready to pass to model
  if (magrittr::and(rlang::is_scalar_character(.latent_variables),
                    all(stringr::str_detect(.latent_variables, stringr::fixed("=~"))))) {
    # Pass directly
    .model <- .latent_variables
  } else if (all(stringr::str_detect(.latent_variables, stringr::fixed("=~")))) {
    # If a character vector of lavaan model latent variable =~ indicators is passed, paste into 1 string
    .model <- .latent_variables %>%
      paste(collapse = "\n ")
  } else {
    # Otherwise assume treat as names of latent variables to generate model with .latent_indicators

    # Coercing .latent_indicators into character vector if presented as list of components
    if (is.list(.latent_indicators)) {
      .latent_indicators <- purrr::map_chr(.latent_indicators, ~paste(., collapse = " + "))
    } else if (rlang::is_scalar_character(.latent_variables)) {
      # If only 1 latent variable, give support to passing a single character vector
      # Safe paste as if a single string given, will do nothing
      .latent_indicators <- paste(.latent_indicators, collapse = " + ")
    }
    # Pasting model together
    .model <- paste(.latent_variables, .latent_indicators, sep = " =~ ", collapse = "\n ")
  }
  cfa_model <- lavaan::cfa(.model, data = .dataset)

  # Fit statistics
  cfa_fit <- lavaan::fitMeasures(cfa_model, fit.measures = .fit_measures) %>%
    purrr::imap_dfr(~tibble::tibble(Statistic = .y, Value = round(.x, 3)))

  # Factor Loadings
  cfa_loadings <- lavaan::parameterEstimates(cfa_model, standardized = TRUE) %>%
    tibble::as_tibble()
  .loading_parameters <- c("Latent Variable", "Latent Indicator", .loading_parameters)
  loadings_selection <- dplyr::case_when(
    .loading_parameters == "Latent Variable" ~ "lhs",
    .loading_parameters == "Latent Indicator" ~ "rhs",
    .loading_parameters == "Operator" ~ "op",
    .loading_parameters == "Estimate" ~ "est",
    .loading_parameters == "Standard Error" ~ "se",
    .loading_parameters == "Z Score" ~ "z",
    .loading_parameters == "P Value" ~ "pvalue",
    .loading_parameters == "Confidence Interval Lower" ~ "ci.lower",
    .loading_parameters == "Confidence Interval Upper" ~ "ci.upper",
    .loading_parameters == "Standardized Estimate on Latent" ~ "std.lv",
    .loading_parameters == "Standardized Estimates on All" ~ "std.all",
    .loading_parameters == "Standardized Estimates on All Excluding Exogenous" ~ "std.nox",
    TRUE ~ .loading_parameters
  )

   cfa_loadings <- cfa_loadings %>%
     dplyr::select(dplyr::all_of(loadings_selection)) %>%
     dplyr::rename_with(~return(.loading_parameters))
   # Attaching stars if p values listed
   if ("P Value" %in% names(cfa_loadings)) {
     cfa_loadings <- cfa_loadings %>%
       dplyr::mutate(`P Value Stars` = create_stars(`P Value`), .after = `P Value`)
   }
   # Adding Labels to loadings if available
   if (!missing(.latent_labels)) {
     if (is.character(.latent_labels) & is.null(names(.latent_labels))) {
       # If passing unnamed character vector, assume only latent variables passed
       .latent_labels <- tibble::tibble(COLUMN_NAME = .latent_variables,
                                        COLUMN_LABEL = .latent_labels)
     } else if (is.character(.latent_labels) & !is.null(names(.latent_labels))) {
       # If passing named character vector, assume names are of original variable names
       .latent_labels <- tibble::tibble(COLUMN_NAME = names(.latent_labels),
                                        COLUMN_LABEL = .latent_labels)
     } # Otherwise assume that label dataframe is passed with
     # Attaching labels for latent variable and indicator
     cfa_loadings <- cfa_loadings %>%
       dplyr::left_join(.latent_labels, by = c("Latent Variable" = "COLUMN_NAME")) %>%
       dplyr::rename("Latent Variable Label" = "COLUMN_LABEL") %>%
       dplyr::left_join(.latent_labels, by = c("Latent Indicator" = "COLUMN_NAME")) %>%
       dplyr::rename("Latent Indicator Label" = "COLUMN_LABEL") %>%
       dplyr::relocate("Latent Variable",
                       "Latent Variable Label",
                       "Latent Indicator",
                       "Latent Indicator Label")
   }

   # Format and export to excel file if desired
   if (!missing(.output_file)) {
     wb <- openxlsx::createWorkbook()
     openxlsx::addWorksheet(wb, "CFA")
     openxlsx::writeDataTable(wb, 1, cfa_fit)
     openxlsx::writeDataTable(wb, 1, cfa_loadings, startRow = nrow(cfa_fit) + 2)

     create_excel(.output_file,
                  rlang::maybe_missing(.output_path),
                  wb)
   }

   return(list("fit" = cfa_fit, "loadings" = cfa_loadings))
}
